# -*- coding: utf-8 -*-
# @Time    : 2021/7/6 13:45
# @File    : test.py
x = 99


def f1():
    x = 88

    def f2():
        print('f2:', x)

    f2()


f1()
print(x)

# 可以看出，f1中的嵌套变量x覆盖了全局变量x=99，然后f2中的本地变量按照引用规则，就引用了x=88。
print('-' * 30)


# 下面我们来说说嵌套作用域的一个特殊之处:
def f1():
    x = 88

    def f2():
        print('f2:', x)

    return f2


action = f1()
action()

# 本地作用域在函数结束后就立即失效，而嵌套作用域在嵌套的函数返回后却仍然有效。
# 这个例子非常重要，也很有意思，函数f1中定义了函数f2，f2引用了f1嵌套作用域内的变量x，并且f1将函数f2作为返回对象进行返回。
# 最值得注意的是我们通过变量action获取了返回的f2，虽然此时f1函数已经退出结束了，但是f2仍然记住了f1嵌套作用域内的变量名x。
# 上面这种语言现象称之为闭包：一个能记住嵌套作用域变量值的函数，尽管作用域已经不存在。
#
# 这里有一个应用就是工厂函数，工厂函数定义了一个外部的函数，
# 这个函数简单的生成并返回一个内嵌的函数，仅仅是返回却不调用，因此通过调用这个工厂函数，
# 可以得到内嵌函数的一个引用，内嵌函数就是通过调用工厂函数时，运行内部的def语句而创建的。
print('-' * 30)


def maker(n):
    k = 8

    def action(x):
        return x ** n + k

    return action


f = maker(2)
print(f)
print(f(4))

# 这里我们可以看出，内嵌的函数action记住了嵌套作用域内得两个嵌套变量，一个是变量k，一个是参数n，即使后面maker返回并退出。
# 我们通过调用外部的函数maker，得到内嵌的函数action的引用。这种函数嵌套的方法在后面要介绍的装饰器中会经常用到。
# 这种嵌套作用域引用，就是python的函数能够保留状态信息的主要方法了。
# 这里接着说说另一个关键字nonlocal
# 本地函数通过global声明对全局变量进行引用修改，那么对应的，内嵌函数内部想对嵌套作用域中的变量进行修改，就要使用nonlocal进行声明。
print('-' * 30)


def test(num):
    in_num = num

    def nested(label):
        nonlocal in_num
        in_num += 1
        print(label, in_num)

    return nested


F = test(0)
F('a')
F('b')
F('c')

G = test(0)
G('d')
F('e')
# 这里我们可以看到几个点，我们在nested函数中通过nonlocal关键字引用了内嵌作用域中的变量in_num，
# 那么我们就可以在nested函数中修改他，即使test函数已经退出调用，这个“记忆”依然有效。
# 多次调用工厂函数返回的不同内嵌函数副本F和G，彼此间的内嵌变量in_num是彼此独立隔离的。
